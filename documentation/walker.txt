
Pseudo code for file system walker.

Overall goal is to iterate over $backup_dirs and notice any deleted,
modified, or created files/directories.  Then build a queue of the
changed files sorted by inode.

First note the time of the start of the backup.

Please note in the common case (most files already backed up)
it does one SQL statement per directory.

// interate through the directory array
for i < len(dirArray)
{
	// inside add_dir_to_sql should only insert if dir isn't in sql
	add_dir_to_sql(i)

	// build list of files in this directory
	d, err := os.Open(dirname)
	fi, err := d.Readdir(-1)

	// build list of files from sql
	sqlList  = get_list_of_files_in_dir(i)

	// iterate over list of files in current directory
	for _, fi := range fi {
		if !fi.IsDir() {
			// return zero if file not in sql
			modtime := get_modified_time(sqllist(fi.Name))
			// compare the local modified time for this file to the one in sql
			if fi.Modified_time > modtime
				insert_local_file_meta_data_into_sql(...)
				send_to_upload_channel(Upchannel,fi)
			} else {
			// if dir isn't in sql add it 
			// if dir isn't in dirArray append it.
		}
	}
	while (fi:=FileHasBeenUploaded(DownChannel)	)
	{
		insert_file(fi)
	}
}

Once done the encryption queue should be sorted by inode.

Then addDir and addFile are functions that compare what's on the filesystem with what is
in the database:
* BOTH addFile and addDir update last_seen for EVERYTHING it sees.
* NEVER modify a file or directory with metadata from stat, ALWAYS insert.
* Add directory to SQL if missing or modified.
* Adds file to sql if missing,modified metadata, or modified conetns, and queue it for encryption

One key step is that after the above any file with last_seen older than
the start of the current backup must have been deleted and that needs
to be noted.

Something like:
update files set deleted=TRUE where deleted=FALSE and last_seen < $start_of_backup.



 
